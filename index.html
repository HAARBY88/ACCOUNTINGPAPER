import type { Handler } from '@netlify/functions';
import OpenAI from 'openai';
import pg from 'pg'; // for pgvector via Postgres

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const pool = new pg.Pool({ connectionString: process.env.DATABASE_URL });

export const handler: Handler = async (event) => {
  try {
    const { facts, framework, k = 8 } = JSON.parse(event.body || '{}');

    // 1) embed the query
    const emb = await openai.embeddings.create({
      model: 'text-embedding-3-large',
      input: `${framework}\n${facts}`
    });
    const vec = emb.data[0].embedding;

    // 2) retrieve top-k chunks (pgvector cosine distance)
    const client = await pool.connect();
    const { rows } = await client.query(
      `SELECT text, metadata
       FROM chunks
       ORDER BY embedding <-> $1
       LIMIT $2`,
       [Buffer.from(new Float32Array(vec).buffer), k]
    );
    client.release();

    const context = rows.map((r, i) =>
      `[[${i+1}]] ${r.text}\n(meta: ${JSON.stringify(r.metadata)})`
    ).join('\n\n');

    // 3) compose prompt
    const system = `You are a senior technical accountant writing auditor-ready papers. 
- Cite all claims to sources using bracketed refs like [1], [2].
- Structure: Background; Facts; Accounting Analysis; Judgements & Alternatives; Conclusion; References.
- Only use the provided context; if insufficient, say whatâ€™s missing.`;

    const user = `Framework: ${framework}
Facts: ${facts}

Context (retrieved):
${context}

Write the memo. Include a References section mapping [n] to (source, section/page).`;

    // 4) generate
    const chat = await openai.chat.completions.create({
      model: 'gpt-5.1', // or your chosen model
      messages: [
        { role: 'system', content: system },
        { role: 'user', content: user }
      ],
      temperature: 0.2
    });

    return {
      statusCode: 200,
      body: JSON.stringify({ memo: chat.choices[0].message?.content || '' })
    };
  } catch (e:any) {
    return { statusCode: 500, body: e.message || 'error' };
  }
};
